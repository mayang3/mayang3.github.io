# 6. Mutex vs Monitor
#Java/multithreaed/basic
1. 앞서 토론했던 locking 과 signaling mechanism 에 이어, 고급 주제인 monitor 에 대해 알아보자. 그것은 Java 와 같은 언어 framework 에서는 동시성 구조로 표현된다.


## When Mutual Exclusion isn’t Enough
1. 간단히 말해서 monitor 는 mutex 이고 그외에 몇가지를 더 첨가한 것이라고 할 수 있다.
2. mutex 와 semaphore 는 OS 가 제공하는 구조의 level 인 반면에 monitor 는 language level 의 구조라고 할 수 있다.
3. 모니터를 이해하기 위해 다음 예제를 확인해 보자. 
4. multi-thread program 에서 thread 는 몇몇의 조건부가 참이될때까지 기다리는 작업이 필요하다. 
5. producer / consumer pattern 을 생각해보자. 만약 producer 가 아무것도 생산하지 않았다면 consumer 는 어떤것을 consume 할지를 알 수가 없다. 그래서 consumer 는 반드시 어떠한 조건이 consumer 에서 consume 을 해야한다는 것을 알려줄때까지 기다려야 한다. 이 일을 하기 위한 근본적인 방법이 무엇일까? consumer 는 반복적으로 loop 을 돌며 조건이 참인지를 체크할수가 있다. 아래 패턴이 그 코드의 pseudo code 를 나타낸다. 

``` java

void busyWaitFunction() {
    // acquire mutex 
    while (predicate is false) {
      // release mutex
      // acquire mutex
    }
    // do something useful
    // release mutex
}

```
7. 위 코드에 대해 간단히 보면, 최초 mutex 를 획득한 후에, predicate 가 false 라면 다시 mutex 를 해제해준다. -> 여기서 mutex 를 해제해 주는 이유는 다른 thread 도 predicate 에 접근할 수 있어야 하기 때문이다. 왜냐하면 여러개의 consumer 중 하나가 predicate 가 true 가 되는 순간 바로 바로 처리할 수 있어야 하는데, predicate 가 true 가 될때까지 mutex 를 풀지 않으면, thread 가 하나씩 serial 하게 처리하는 것과 다를바가 없다.
8. 그리고 predicate 변수를 확인하기 전에 다시 mutex 를 획득한다. -> predicate 는 shared variable 이기 때문에 critical section 이다. 이 부분은 guard 되어야 한다.
9. 이 코드는 동작은 하지만 CPU cycle 의 많은 부분을 낭비하게 된다. -> 일명 “spin wait” 문제이다.
10. 아래 “spin issue” 를 어떻게 해결하는지 확인해보자.

## Condition Variables
1. mutex 는 상호배제를 제공하지만 이것으로는 충분하지 않는 경우가 있다.
2. 위의 예제를 보면 우리는 mutex 를 사용하여 조건부 를 check 할때 다른 thread 가 predicate 값을 변경할 수 없도록 하고 있다. 
3. 그러나 잘 생각해보면 우리가 원하는 것은 predicate 가 false 일 경우, 우리는 predicate 값이 바뀌기를 기다리는것을 원하는 것임을 알 수 있다. -> 이것이 바로 spning waiting 의 해결 실마리가 된다.

``` java

void efficientWaitingFunction() {
    mutex.acquire() 
    while (predicate == false) {
      condVar.wait() // 기다렸다가, signal 받으면 다시 mutex 획득
    }
    // Do something useful
    mutex.release()     
} 

void changePredicate() { 
    mutex.acquire()
    set predicate = true
    condVar.signal()
    mutex.release()
}

```

5. 위의 예제를 보자. 개념적으로 각각의 condition variable (조건 변수) 들은 각각 wait() 와 signal() 의 두개의 method 를 노출한다. 여기서 wait() method 는 호출한 thread 의 mutex 를 해제하고 호출한 thread 를 wait queue 에 위치시키는 것을 의미한다. 그리고 wait queue 안에는 이전이 이미 호출되었던 thread 들이 대기하고 있을 수 있다.
6. mutex 는 이제 release 되었기 때문에, 다른 thread 에게 predicate 를 변경할 수 있는 기회를 주게된다.
7. 예를 들어, 어떠한 buffer 의 크기를 검사하고 만약 buffer 가 비어있다면, wait() 을 호출하는 conditional variable 을 생각해보자. 이 예제에서 predicate 란 buffer 의 size 이다.
	1. thread A 가 efficientWaitingFunction() 에 먼저 접근해서 mutex 를 획득하고 predicate 를 검사한다. buffer 의 사이즈는 현재 0 이기 때문에 wait() 가 호출되고 mutex 를 해제한다. -> thread A 는 wait queue 에 들어가게 된다.
	2. thread A 가 mutex 를 해제했기 때문에 producer 인 thread B 는 mutex 를 획득한다. 그리고 predicate 를 true 로 바꾸고 signal() 을 호출한다. 이 시점에 thread A 는 mutex 를 재획득하기 위한 read queue (실행 대기 큐) 에 들어간다.
	3. thread B 가 mutex 를 해제 하는 순간 thread A 는 다시 mutex 를 획득하게 되고 다시 실행할 수 있게 된다. 그리고 실행이 완료되면 mutex 를 해제한다.
	4. 여기서 thread B 의 signal() method 호출과 mutex 해제는 순서가 바뀔 수도 있다. 하지만 보통 signal() 후에 mutex 를 해제하는 것이 안전하다.
	
## Why While loop?
**중요한 결론을 먼저 이야기하면, “monitor 의 올바른 사용법에서 predicate 는 항상 while loop 으로 체크되어야 한다” 는 것이다.** 

``` java

void efficientWaitingFunction() {
    mutex.acquire() 
    if (predicate == false) {
      condVar.wait()
    }
    // Do something useful
    mutex.release()     
} 

```

1. while loop 대신 if 로 처리한 위의 코드가 정상적으로 동작하려면, codVar이 signal 되었고, wake up 한 thread 가 그것을 처리하기 전까지 다른 thread 가 절대로 predicate 를 변경할 수 없어야 한다. -> 하지만 therad B 가 mutex 를 해제하고 wake up 한 thread A 가 다시 mutex 를 획득하기 전에 다른 thread 가 얼마든지 predicate 를 다시 false 로 변경할 수가 있다.
2. 또한 POSIX system 에서는 predicate 가 변경되지 않았다 하더라도,  fake wakeup 이 일어날 수 있다.

## Monitor Explained
1. **Monitor = mutex + one or more condition variable.**
2. **Monitor = “mutex with wait set”** 이렇게 표현할 수도 있다.
3. 하나의 monitor 는 여러개의 condition variable 을 가지는 것이 가능하지만 그 반대는 불가능하다.
4. 이론적으로 monitor 에 대해 생각해보는 또다른 방식은 monitor 를 2개의 queue 또는  set 을 갖는 entity 로 생각하는 것이다.
	1. 2개중 하나는 entry set 이고 또 다른 하나는 wait set 이다.
	2. thread A 가 monitor 에 최초 진입했을때 그 thread 는 entry set 에 위치한다.
	3. 만약 다른 thread 가 monitor 를 소유하고 있지 않다면 (monitor 영역에서 동작하고 있는 thread 가 없다면), thread A 는 monitor 를 획득할 것이다.
	4. thread A 는 monitor 를 벗어날때까지 monitor 영역을 실행하거나  condition variable 과 관련된 로직에서 wait() 를 호출하고 wait set  으로 진입할 것이다.
	5. thread A 가 wait set 에 위치하는 동안 thread B 는 monitor 에 대한 소유권을 요청하고 entry set 에 배치된다.
	6. thread B 가 monitor 영역을 실행하고 notify() 를 호출하게 된다면 thread A 가 깨어난다. -> thread B 가 producer 인 경우이다.
	7. 만약 thread B 가 notify() 를 호출하지 않고 wait() 를 호출한다면 thread A 와 같이 wait set 에 위치하게 될 것이다. 이 때는 notirfy() 를 해줄 세번째 thread 가 필요하다.
	8. 실질적으로, java 에서 object 는 monitor 이다. 그리고 암시적인 lock 을 가지며, condition variable 이기도 하다.
	9. monitor 는 wait 와 signal 을 통해 thread 끼리 협력을 하거나 상호배제를 하도록 해준다.

